<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holistic Health Tracker (BP/Glucose)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
    <style>
        /* Global & Reset */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1200px; 
            margin: 0 auto;
            background-color: #f7f9fc;
        }

        h1 {
            color: #1a4f78;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        /* Utility Classes for Conditional Display */
        .display-mobile-only { display: none; }
        .display-desktop-only { display: block; }
        
        @media (max-width: 767px) {
            .display-desktop-only { display: none !important; }
            .display-mobile-only { display: block !important; }
            body { padding: 10px; }
            .controls, #overallAveragesContainer, #todayAveragesContainer, #detailedHistoryContainer { padding: 15px 10px; }
        }

        /* Controls and Inputs */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        .controls label {
            font-weight: bold;
            display: block;
            margin-top: 5px;
            color: #555;
            margin-bottom: 5px;
        }
        
        .controls input[type="date"],
        .controls input[type="time"],
        .controls input[type="number"],
        .controls input[type="text"],
        .controls select,
        #personSelect {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        /* GRID FIXES for Alignment */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
            align-items: start;
        }
        
        /* Person Input Group Styling */
        .person-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #personCustomInput {
            margin-top: 0;
            display: none;
        }

        /* Buttons */
        button {
            padding: 10px 20px;
            margin-top: 10px;
            cursor: pointer;
            font-size: 16px;
            border: none;
            border-radius: 4px;
        }

        .add {
            background: #4CAF50;
            color: white;
        }
        
        .update {
            background: #FF9800; /* Orange for Update */
            color: white;
            display: none; /* Hidden by default */
        }
        
        /* New Table Download Button Style */
        .table-export-btn {
            background: #2196F3; /* Light Blue for table export */
            color: white;
            padding: 8px 15px;
            font-size: 14px;
            margin-top: 10px;
            float: right;
        }
        
        .export-btn {
            background: #007bff; /* Blue for full export */
            color: white;
            margin-top: 15px;
        }

        .logout-btn {
            background: #f44336;
            color: white;
            padding: 5px 15px;
            font-size: 14px;
        }
        
        /* --- TABLE STYLES (Desktop) --- */
        #overallAveragesContainer, #todayAveragesContainer, #detailedHistoryContainer {
            margin-top: 30px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            overflow-x: auto;
        }
        #overallAveragesContainer > .display-desktop-only,
        #todayAveragesContainer > .display-desktop-only,
        #detailedHistoryContainer > .display-desktop-only {
             padding: 15px; /* Padding for desktop table container */
        }

        .data-table {
            width: 100%;
            min-width: 900px; 
            border-collapse: collapse;
            margin-top: 15px;
        }

        .data-table th, .data-table td {
            padding: 12px 10px;
            border: 1px solid #eee;
            text-align: center;
            font-size: 0.9em; 
        }
        
        .data-table thead th {
            background-color: #1a4f78; 
            color: white;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .data-table thead tr:nth-child(2) th {
            background-color: #007bff; /* Blue secondary header */
            color: white;
        }
        
        /* Desktop Bifurcation for Detailed History */
        .data-table thead tr:nth-child(2) th:not(:first-child) {
            border-left: 2px solid #333; 
        }
        
        .data-table tbody tr td:nth-child(3n + 2) { 
            border-left: 1px solid #ddd;
        }
        .data-table tbody tr td:nth-child(3n + 5) { 
             border-left: 2px dashed #ccc; /* Stronger separation after 3 columns */
        }

        .data-table tbody th {
            text-align: left;
            background-color: #f0f8ff; 
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f7f9fc;
        }

        .avg-bp, .avg-reading {
            white-space: nowrap;
            font-weight: bold;
        }
        
        .no-data {
            color: #999;
            font-style: italic;
        }
        
        /* Prominence for Averages Count */
        .count-badge {
            background-color: #ff5722; /* Deep Orange for prominence */
            color: white;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.7em; 
            font-weight: bold;
            display: inline-block; 
            margin-left: 5px;
            min-width: 25px; 
            text-align: center;
        }
        
        /* Action Buttons within Tables */
        .action-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .edit-btn {
            background-color: #4CAF50; /* Green for Edit */
        }
        .action-btn:hover {
            opacity: 0.8;
        }

        /* --- CARD VIEW STYLES (Mobile < 768px) --- */
        .card-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-top: 15px;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }
        
        /* 1. Today's Readings Card Style */
        .person-card-today .today-reading-block {
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-left: 5px solid #2196F3; /* Prominent indicator */
            border-radius: 4px;
            background-color: #f9f9ff;
        }
        .person-card-today .reading-time {
            font-weight: bold;
            color: #1a4f78;
            margin-bottom: 5px;
            display: block;
        }
        .person-card-today .value-prominent {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            display: block;
        }

        /* 2. Overall Averages Card Style */
        .person-card-average h3 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        .metric-group {
            margin-top: 10px;
            border: 1px solid #f0f0f0;
            padding: 8px;
            border-radius: 4px;
        }
        .metric-label {
            font-weight: bold;
            display: block;
            background-color: #f7f9fc;
            padding: 5px;
            margin: -8px -8px 5px -8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .data-point {
            margin-bottom: 3px;
            font-size: 0.95em;
        }

        /* 3. Detailed History Card Style (The most complex requirement) */
        
        /* Date-wise Bifurcation */
        .date-header {
            background: #1a4f78;
            color: white;
            padding: 10px 15px;
            font-weight: bold;
            border-radius: 6px 6px 0 0;
            margin-top: 15px;
            margin-bottom: -15px; /* Collapse margin with the first person card */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        /* Person-wise Bifurcation */
        .person-card-detailed {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-top: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        /* Clear visual separation for the second person onwards on the same date */
        .person-card-detailed:not(:first-of-type) {
            border-left: 5px solid #ff5722; /* Strong orange bar for person separation */
            background-color: #fffaf7; /* Light tint for person grouping */
        }

        .person-card-detailed .person-header {
            font-weight: bold;
            color: #007bff;
            border-bottom: 1px dashed #eee;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .person-card-detailed .reading-row {
            padding: 2px 0;
            font-size: 0.9em;
        }
        .person-card-detailed .reading-value {
            font-weight: bold;
            color: #333;
        }


        /* Auth Styles */
        #authContainer {
            max-width:400px; margin:50px auto; padding:30px; background:#f9f9f9; border-radius:10px;
        }
        .signup-fields { display: none; }
        #authContainer.signup-mode .signup-fields { display: block; }

        /* Navigation Link Style */
        .nav-link {
            text-decoration: none;
            color: white;
            font-weight: bold;
            margin-left: 15px;
            padding: 8px 12px;
            border-radius: 4px;
            background: #2196F3;
            transition: background 0.2s;
        }
        .nav-link:hover {
            background: #0d47a1;
        }

    </style>
</head>
<body>
    
    <div id="authContainer"> 
        <h2>üîí Health Tracker Access</h2>
        <div style="margin:20px 0;">
            <div class="signup-fields">
                <input type="text" id="name" placeholder="Your Name" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            </div>
            <input type="email" id="email" placeholder="Email" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            <input type="password" id="password" placeholder="Password (min 6 chars)" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            <div class="signup-fields">
                <input type="password" id="confirmPassword" placeholder="Confirm Password" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            </div>
        </div>
        <button class="add" onclick="login()" style="width:48%; margin:2%;" id="loginBtn">Login</button>
        <button class="export" onclick="toggleSignupMode()" style="width:48%; margin:2%;" id="signupToggleBtn">Sign Up</button>
        <div id="authError" style="color:red; margin-top:10px;"></div>
    </div>

    <div id="appContainer" style="display:none;">
        <div style="text-align:right; margin-bottom:20px; display:flex; justify-content:flex-end; align-items:center;">
            <a href="index.html" class="nav-link">üíä Medicine Tracker</a>
            
            <span id="userEmail" style="margin-right:10px; font-weight:bold; margin-left: 15px;"></span>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
        
        <h1>‚ù§Ô∏è Daily Health Readings</h1>
        
        <div class="controls">
            <h2>Record a New Reading</h2>
            <div class="input-grid">
                <input type="hidden" id="readingIdToEdit" value="">
                
                <div class="input-group">
                    <label for="recordDate">Date</label>
                    <input type="date" id="recordDate">
                </div>
                
                <div class="input-group">
                    <label for="recordTime">Time</label>
                    <input type="time" id="recordTime">
                </div>

                <div class="input-group">
                    <label for="personSelect">Person Name</label>
                    <div class="person-input-group">
                        <select id="personSelect" onchange="handlePersonChange(this.value)">
                            <option value="" disabled selected>Select a person...</option>
                            <option value="Custom">Add New Person...</option>
                        </select>
                        <input type="text" id="personCustomInput" placeholder="Enter new name here" onblur="handleCustomNameBlur(this.value)">
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="systole">Systolic (BP)</label>
                    <input type="number" id="systole" placeholder="e.g., 120" step="1">
                </div>
                
                <div class="input-group">
                    <label for="diastole">Diastolic (BP)</label>
                    <input type="number" id="diastole" placeholder="e.g., 80" step="1">
                </div>

                <div class="input-group">
                    <label for="glucose">Glucose (mg/dL)</label>
                    <input type="number" id="glucose" placeholder="e.g., 100" step="0.1">
                </div>

                <div class="input-group">
                    <label for="weight">Weight (kg/lbs)</label>
                    <input type="number" id="weight" placeholder="e.g., 75" step="0.1">
                </div>
                
            </div>
            
            <button class="add" id="addButton" onclick="addReading()">Add Reading</button>
            <button class="update" id="updateButton" onclick="updateReading()">Update Reading</button>
            
            <button class="export-btn" onclick="exportFullHistory()">‚¨áÔ∏è Download Full History (CSV)</button>

        </div>
        
        <div id="todayAveragesContainer">
            </div>

        <div id="detailedHistoryContainer">
            </div>

        <div id="overallAveragesContainer">
            </div>

    </div>

    <script type="module">
        // üö® CRITICAL FIX: Make functions global so inline HTML onclick handlers can find them
        window.login = login;
        window.signup = signup;
        window.logout = logout;
        window.toggleSignupMode = toggleSignupMode; 
        window.handlePersonChange = handlePersonChange;
        window.handleCustomNameBlur = handleCustomNameBlur; 
        window.addReading = addReading;
        window.updateReading = updateReading; 
        window.editReading = editReading;     
        window.deleteReading = deleteReading;
        window.loadReadings = loadReadings; 
        window.exportFullHistory = exportFullHistory; 
        window.exportDetailedHistory = exportDetailedHistory; 
        window.exportOverallAverages = exportOverallAverages; 

        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, update, remove } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-database.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-auth.js';

        // ‚ö†Ô∏è CRITICAL WARNING: Please replace this with YOUR actual Firebase Configuration.
        const firebaseConfig = {
            apiKey: "AIzaSyAjRB8_dLv8icceOyZNNGO9kIXUFVjWfoY", // üö® REPLACE THIS PLACEHOLDER KEY! üö®
            authDomain: "medicine-tracker-b90f2.firebaseapp.com",
            databaseURL: "https://medicine-tracker-b90f2-default-rtdb.firebaseio.com",
            projectId: "medicine-tracker-b90f2",
            storageBucket: "medicine-tracker-b90f2.firebasestorage.app",
            messagingSenderId: "230127910329",
            appId: "1:230127910329:web:756789fcd3a1ac02948a68"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        console.log("‚úÖ Firebase initialized successfully. Ready for authentication."); 

        let currentUser = null;
        let allReadings = [];
        let allPersonAveragesCache = {}; // Cache for overall averages
        let detailedHistoryDataCache = {}; // Cache for detailed history data
        let personNames = new Set();
        let currentPerson = '';
        const today = new Date();
        document.getElementById('recordDate').value = today.toISOString().split('T')[0];
        document.getElementById('recordTime').value = today.toTimeString().split(' ')[0].substring(0, 5); 
        const todayDateString = today.toISOString().split('T')[0];

        // --- UTILITY: Check if device is considered mobile/tablet view ---
        function isMobileView() {
            return window.innerWidth < 768; // Standard breakpoint
        }

        // --- UTILITY: Date Formatting (DD-MMM-YY) ---
        function formatDate(dateString) {
            if (!dateString) return '';
            // Use date only part to prevent timezone shift issues on Date object creation
            const date = new Date(dateString + 'T00:00:00'); 
            
            const day = date.getDate().toString().padStart(2, '0');
            const year = date.getFullYear().toString().slice(-2);
            
            const monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            const month = monthNames[date.getMonth()];

            return `${day}-${month}-${year}`;
        }
        
        // --- AUTH & SYNC ---
        function toggleSignupMode() {
            const container = document.getElementById('authContainer');
            const toggleBtn = document.getElementById('signupToggleBtn');
            const isSignupMode = container.classList.contains('signup-mode');

            if (isSignupMode) {
                container.classList.remove('signup-mode');
                toggleBtn.textContent = 'Sign Up';
                toggleBtn.onclick = toggleSignupMode;
            } else {
                container.classList.add('signup-mode');
                toggleBtn.textContent = 'Register';
                toggleBtn.onclick = signup;
            }
            document.getElementById('authError').textContent = '';
        }

        function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorEl = document.getElementById('authError');
            const loginBtn = document.getElementById('loginBtn'); // Reference the login button
            
            // 1. Immediate Visual Feedback & Prevention of Double Clicks
            errorEl.textContent = 'Processing...'; 
            loginBtn.disabled = true; 

            if (!email || !password) { 
                errorEl.textContent = 'Please enter email and password'; 
                loginBtn.disabled = false; // Re-enable on validation failure
                console.error("‚ùå Login failed: Email or password is empty."); 
                return; 
            }
            
            console.log('üîÑ Attempting login for:', email); 

            try {
                signInWithEmailAndPassword(auth, email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        errorEl.textContent = '';
                        console.log('‚úÖ Login successful. User:', currentUser.uid); 
                        // Do NOT re-enable button, showApp() will hide the container
                        showApp();
                    })
                    .catch((error) => {
                        // 2. Clear error on promise rejection and re-enable button
                        const displayMessage = `Login failed: ${error.code} - ${error.message}`;
                        errorEl.textContent = displayMessage;
                        loginBtn.disabled = false; 
                        console.error('‚ùå Firebase Auth Error:', displayMessage, error); 
                    });
            } catch(e) {
                 // 3. Catch any synchronous JS errors that could block the flow
                errorEl.textContent = 'Critical Error during login: ' + e.message;
                loginBtn.disabled = false; 
                console.error('‚ùå Synchronous JavaScript Error:', e); 
            }
        }

        function signup() {
            const name = document.getElementById('name').value;
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            const errorEl = document.getElementById('authError');
            const signupToggleBtn = document.getElementById('signupToggleBtn');
            
            errorEl.textContent = 'Registering...';
            signupToggleBtn.disabled = true;

            if (!name || !email || !password || !confirmPassword || password !== confirmPassword) {
                errorEl.textContent = 'Please check all fields and ensure passwords match.';
                signupToggleBtn.disabled = false;
                return;
            }

            createUserWithEmailAndPassword(auth, email, password)
                .then((userCredential) => {
                    currentUser = userCredential.user;
                    const userRef = ref(db, 'users/' + currentUser.uid + '/profile');
                    set(userRef, { name: name, email: email }).then(() => {
                        console.log('‚úÖ Signup successful and profile created.'); 
                        showApp();
                    });
                })
                .catch((error) => {
                    errorEl.textContent = 'Signup failed: ' + error.message;
                    signupToggleBtn.disabled = false;
                    console.error('‚ùå Firebase Signup Error:', error); 
                });
        }

        function logout() {
            if (confirm('Logout?')) {
                signOut(auth).then(() => {
                    currentUser = null;
                    console.log('üëã User logged out.'); 
                    showLogin();
                });
            }
        }

        function showLogin() {
            document.getElementById('authContainer').style.display = 'block';
            document.getElementById('appContainer').style.display = 'none';
        }

        function showApp() {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('appContainer').style.display = 'block';
            console.log('üöÄ App view shown.'); 
            
            const profileRef = ref(db, 'users/' + currentUser.uid + '/profile/name');
            onValue(profileRef, (snapshot) => {
                const userName = snapshot.val();
                document.getElementById('userEmail').textContent = userName || currentUser.email;
            }, { onlyOnce: true });

            setupRealtimeSync(); 
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                console.log('üë§ Auth state changed: Logged In.', user.email); 
                showApp();
            } else {
                currentUser = null;
                console.log('üö´ Auth state changed: Logged Out.'); 
                showLogin();
            }
        });

        let syncListener = null;
        function setupRealtimeSync() {
            if (!currentUser) return;
            if (syncListener) syncListener(); 

            // Path check is critical
            const readingsRef = ref(db, 'users/' + currentUser.uid + '/healthReadings');
            console.log('üì° Setting up real-time database sync.'); 

            syncListener = onValue(readingsRef, (snapshot) => {
                const data = snapshot.val(); 
                allReadings = [];
                personNames.clear();

                if (data) {
                    for (const key in data) {
                        const reading = { id: key, ...data[key] };
                        allReadings.push(reading);
                        if (reading.person) {
                            personNames.add(reading.person);
                        }
                    }
                }
                // Sort by date and then time descending
                allReadings.sort((a, b) => {
                    // Normalize time to handle potential undefined fields
                    const dateA = new Date(a.date + ' ' + (a.time || '00:00'));
                    const dateB = new Date(b.date + ' ' + (b.time || '00:00'));
                    return dateB - dateA;
                });
                
                // **CRITICAL FIX:** Ensure currentPerson is set based on first available data person, or the highest sorted name
                const sortedNames = Array.from(personNames).sort();
                if (sortedNames.length > 0 && (!currentPerson || !personNames.has(currentPerson))) {
                    currentPerson = sortedNames[0]; // Set to the first person name available
                    updatePersonDropdown(true); 
                } else {
                    updatePersonDropdown();
                }
                
                // CRITICAL STEP: Call the main display function after data sync and initialization
                loadReadings(); 
                resetForm(); // Reset form state after sync

            }, (error) => {
                console.error('‚ùå Real-time sync error: Failed to read from database. Check Firebase Security Rules.', error);
                // Clear UI on critical failure
                loadReadings(); 
            });
        }
        
        // --- PERSON MANAGEMENT (Unchanged) ---
        function updatePersonDropdown(forceSelect = false) {
            const select = document.getElementById('personSelect');
            const customInput = document.getElementById('personCustomInput');
            
            select.innerHTML = '';
            select.innerHTML += `<option value="" disabled selected>Select a person...</option>`;
            
            const sortedNames = Array.from(personNames).sort();
            
            // Re-check currentPerson against the newly synced names
            if (!currentPerson || !personNames.has(currentPerson)) {
                if (sortedNames.length > 0) {
                    currentPerson = sortedNames[0]; // If the current selection is gone, pick the first one
                    forceSelect = true;
                } else {
                    currentPerson = '';
                }
            }

            sortedNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                if (forceSelect && name === currentPerson) {
                     option.selected = true;
                }
                select.appendChild(option);
            });
            
            const customOption = document.createElement('option');
            customOption.value = "Custom";
            customOption.textContent = "Add New Person...";
            select.appendChild(customOption);
            
            if (currentPerson && !forceSelect) {
                select.value = currentPerson;
            } else if (!currentPerson) {
                select.value = "";
            }

            if (select.value === 'Custom') {
                customInput.style.display = 'block';
            } else {
                customInput.style.display = 'none';
            }
        }
        
        function handlePersonChange(value) {
            const customInput = document.getElementById('personCustomInput');
            if (value === 'Custom') {
                customInput.style.display = 'block';
                customInput.value = '';
                customInput.focus();
            } else if (value) {
                currentPerson = value;
                customInput.style.display = 'none';
                loadReadings(); 
            }
        }
        
        function handleCustomNameBlur(value) {
            const newName = value.trim();
            const select = document.getElementById('personSelect');
            const customInput = document.getElementById('personCustomInput');
            
            if (newName) {
                currentPerson = newName;
                personNames.add(newName);
                updatePersonDropdown(true);
                customInput.style.display = 'none';
                loadReadings();
            } else {
                if (currentPerson) {
                    select.value = currentPerson;
                } else {
                    select.value = "";
                    customInput.style.display = 'none';
                }
            }
        }
        
        // --- FORM STATE MANAGEMENT (Unchanged) ---
        function resetForm() {
            const now = new Date();
            document.getElementById('recordDate').value = now.toISOString().split('T')[0];
            document.getElementById('recordTime').value = now.toTimeString().split(' ')[0].substring(0, 5); 
            document.getElementById('systole').value = '';
            document.getElementById('diastole').value = '';
            document.getElementById('glucose').value = '';
            document.getElementById('weight').value = '';
            document.getElementById('readingIdToEdit').value = '';

            document.getElementById('addButton').style.display = 'block';
            document.getElementById('updateButton').style.display = 'none';
            
            // Re-select the current person if one exists, otherwise keep "Select a person..."
            if (currentPerson) {
                document.getElementById('personSelect').value = currentPerson;
            } else {
                 document.getElementById('personSelect').value = '';
            }
        }


        // --- CORE CRUD & UI LOGIC (Unchanged) ---
        function getReadingData(isUpdate = false) {
            if (!currentUser || !currentPerson) {
                alert("Please select or enter a person's name first.");
                return null;
            }
            
            const date = document.getElementById('recordDate').value;
            const time = document.getElementById('recordTime').value;
            const systoleValue = document.getElementById('systole').value;
            const diastoleValue = document.getElementById('diastole').value;
            const glucoseValue = document.getElementById('glucose').value;
            const weightValue = document.getElementById('weight').value;
            
            const systole = Number(systoleValue) || null;
            const diastole = Number(diastoleValue) || null;
            const glucose = Number(glucoseValue) || null;
            const weight = Number(weightValue) || null;
            
            if (!date || !time) {
                alert("Please enter both date and time.");
                return null;
            }
            if (!systole && !diastole && !glucose && !weight) {
                alert("Please enter at least one reading.");
                return null;
            }

            const readingData = {
                date: date,
                time: time,
                person: currentPerson,
                systole: systole,
                diastole: diastole,
                glucose: glucose,
                weight: weight,
            };
            
            if (!isUpdate) {
                readingData.timestamp = Date.now();
            }

            return readingData;
        }

        // Add (Create)
        function addReading() {
            const newReading = getReadingData(false);
            if (!newReading) return;

            const readingsRef = ref(db, 'users/' + currentUser.uid + '/healthReadings');
            
            push(readingsRef, newReading) 
                .then(() => resetForm())
                .catch(err => alert('Failed to save reading: ' + err.message));
        }
        
        // Edit (Read existing data into form)
        function editReading(id) {
            const reading = allReadings.find(r => r.id === id);
            if (!reading) {
                alert("Reading not found.");
                return;
            }
            
            document.getElementById('readingIdToEdit').value = id;
            document.getElementById('recordDate').value = reading.date || todayDateString;
            document.getElementById('recordTime').value = reading.time || '00:00';
            document.getElementById('systole').value = reading.systole !== null ? reading.systole : '';
            document.getElementById('diastole').value = reading.diastole !== null ? reading.diastole : '';
            document.getElementById('glucose').value = reading.glucose !== null ? reading.glucose : '';
            document.getElementById('weight').value = reading.weight !== null ? reading.weight : '';
            
            // Set person and switch button visibility
            currentPerson = reading.person;
            document.getElementById('personSelect').value = reading.person;
            document.getElementById('addButton').style.display = 'none';
            document.getElementById('updateButton').style.display = 'block';

            window.scrollTo(0, 0); // Scroll to top to show the form
        }

        // Update (Save changes to an existing reading)
        function updateReading() {
            const id = document.getElementById('readingIdToEdit').value;
            if (!id) {
                alert("Error: No reading selected for update.");
                return;
            }

            const updatedData = getReadingData(true);
            if (!updatedData) return;

            const readingRef = ref(db, `users/${currentUser.uid}/healthReadings/${id}`);
            
            // Only update the data fields, not the original timestamp
            update(readingRef, updatedData)
                .then(() => {
                    alert("Reading updated successfully!");
                    resetForm();
                })
                .catch(err => alert('Failed to update reading: ' + err.message));
        }

        // Delete (Destroy)
        function deleteReading(id) {
            if (!currentUser || !id) return;
            if (confirm('Are you sure you want to delete this reading?')) {
                const readingRef = ref(db, `users/${currentUser.uid}/healthReadings/${id}`);
                remove(readingRef).catch(err => console.error('Delete failed:', err));
            }
        }

        // --- MAIN DISPLAY FUNCTION (Calls all table generators) ---
        function loadReadings() {
            // Check for initial empty state
            if (!currentUser || allReadings.length === 0) { 
                const emptyMessage = '<p style="text-align:center; color:#777;">No readings found. Add one above!</p>';
                document.getElementById('todayAveragesContainer').innerHTML = `<h2>‚òÄÔ∏è Today's Individual Readings (${formatDate(todayDateString)})</h2>${emptyMessage}`;
                document.getElementById('detailedHistoryContainer').innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center;"><h2>üìÖ Detailed 30-Day Reading History (Latest Reading/Day)</h2><button class="table-export-btn" onclick="exportDetailedHistory()">‚¨áÔ∏è Download Table (CSV)</button></div><p style="text-align: center; font-style: italic; color: #555;">Showing the **latest recorded reading** for each person on a given day across the last 30 days.</p>${emptyMessage}`;
                document.getElementById('overallAveragesContainer').innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center;"><h2>üìà Overall Averages Summary</h2><button class="table-export-btn" onclick="exportOverallAverages()">‚¨áÔ∏è Download Table (CSV)</button></div>${emptyMessage}`;
                return;
            }
            
            calculateAndDisplayTables();
        }

        // Helper function for calculation
        function calculate(data, metric) {
            // Filter out readings where the metric value is explicitly null or undefined
            const validData = data.filter(r => r[metric] !== null && r[metric] !== undefined);
            if (validData.length === 0) return { avg: null, count: 0 };
            
            // FIX: Ensure only valid, filtered values are summed.
            const sum = validData.reduce((acc, r) => acc + Number(r[metric]), 0);
            return { avg: sum / validData.length, count: validData.length };
        }

        // --- CALCULATION LOGIC (Processes ALL people) ---
        function calculateAndDisplayTables() {
            const metrics = ['systole', 'diastole', 'glucose', 'weight'];
            allPersonAveragesCache = {}; // Reset cache
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const oneWeekAgo = new Date(today); oneWeekAgo.setDate(today.getDate() - 7);
            const oneMonthAgo = new Date(today); oneMonthAgo.setMonth(today.getMonth() - 1);

            // Group all readings by person
            const readingsByPerson = {};
            allReadings.forEach(r => {
                if (!r.person) return; 
                
                if (!readingsByPerson[r.person]) {
                    readingsByPerson[r.person] = [];
                }
                readingsByPerson[r.person].push(r);
            });

            // Ensure personNames reflects all keys we found
            Array.from(personNames).sort().forEach(person => {
                const personReadings = readingsByPerson[person] || [];
                
                const filtered = {
                    day: personReadings.filter(r => r.date === todayDateString),
                    week: personReadings.filter(r => new Date(r.date) >= oneWeekAgo),
                    month: personReadings.filter(r => new Date(r.date) >= oneMonthAgo),
                };
                
                const results = {};
                metrics.forEach(metric => {
                    results[metric] = {
                        day: calculate(filtered.day, metric),
                        week: calculate(filtered.week, metric),
                        month: calculate(filtered.month, metric),
                    };
                });
                
                allPersonAveragesCache[person] = results;
            });

            // Display all tables
            displayTodayReadings(readingsByPerson); // Pass raw readings
            displayAllAverages(allPersonAveragesCache);
            displayDetailedHistory(readingsByPerson);
        }
        
        // --- FORMATTING HELPERS ---
        const formatBP = (sys, dia, isMobile = false) => {
            const bpCount = Math.min(sys.count, dia.count); // BP count should be the minimum of S and D
            if (sys.avg === null || dia.avg === null) return `<span class="no-data">N/A</span>`;
            
            const value = `${sys.avg.toFixed(isMobile ? 0 : 0)}/${dia.avg.toFixed(isMobile ? 0 : 0)}`;
            const count = isMobile ? '' : ` <span class="count-badge">${bpCount} R</span>`;
            return `<span class="avg-bp">${value}</span>${count}`;
        };
        
        const formatMetric = (data, isMobile = false) => {
            if (data.avg === null) return `<span class="no-data">N/A</span>`;
            
            const value = data.avg.toFixed(1);
            const count = isMobile ? '' : ` <span class="count-badge">${data.count} R</span>`;
            return `<span class="avg-reading">${value}</span>${count}`;
        };
        
        // --- DISPLAY 1: Today's Individual Readings (Table/Card) ---
        function displayTodayReadings(readingsByPerson) {
            const container = document.getElementById('todayAveragesContainer');
            
            // Get today's readings, sorted by person and then time
            const allPersonTodayReadings = {};
            const personsWithData = Array.from(personNames).filter(person => {
                const dayReadings = (readingsByPerson[person] || []).filter(r => r.date === todayDateString);
                if (dayReadings.length > 0) {
                    allPersonTodayReadings[person] = dayReadings.sort((a,b) => (a.time || '00:00').localeCompare(b.time || '00:00'));
                    return true;
                }
                return false;
            }).sort();
            
            let contentHTML = `<h2>‚òÄÔ∏è Today's Individual Readings (${formatDate(todayDateString)})</h2>`;
            if (personsWithData.length === 0) {
                container.innerHTML = contentHTML + `<p style="text-align:center; color:#777;">No readings recorded today.</p>`;
                return;
            }
            
            // --- DESKTOP TABLE VIEW ---
            let desktopHTML = `<div class="display-desktop-only">`;
            const allTimes = new Set();
            personsWithData.forEach(person => {
                allPersonTodayReadings[person].forEach(r => {
                    if (r.time) allTimes.add(r.time);
                });
            });
            const sortedTimes = Array.from(allTimes).sort();

            desktopHTML += `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            ${personsWithData.map(person => `<th>${person}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            sortedTimes.forEach(time => {
                desktopHTML += `<tr><th>${time}</th>`;
                
                personsWithData.forEach(person => {
                    const reading = allPersonTodayReadings[person].find(r => r.time === time);
                    
                    if (reading && reading.id) { 
                        const sys = Number(reading.systole) || null;
                        const dia = Number(reading.diastole) || null;
                        const glu = Number(reading.glucose) || null;
                        const wei = Number(reading.weight) || null;

                        const bp = (sys !== null && dia !== null) ? `${sys}/${dia}` : '';
                        const glucose = glu !== null ? glu.toFixed(1) : '';
                        const weight = wei !== null ? wei.toFixed(1) : '';
                        
                        desktopHTML += `
                            <td style="text-align: left;">
                                <div class="detail-reading" style="font-weight: bold;">
                                    BP: ${bp || '<span class="no-data">N/A</span>'} | 
                                    Gl: ${glucose || '<span class="no-data">N/A</span>'} | 
                                    W: ${weight || '<span class="no-data">N/A</span>'} 
                                    <button class="action-btn edit-btn" onclick="editReading('${reading.id}')">‚úèÔ∏è</button>
                                    <button class="action-btn" onclick="deleteReading('${reading.id}')">X</button>
                                </div>
                            </td>
                        `;
                    } else {
                        desktopHTML += `<td><span class="no-data">-</span></td>`;
                    }
                });
                
                desktopHTML += `</tr>`;
            });

            desktopHTML += `</tbody></table></div>`;
            
            // --- MOBILE CARD VIEW ---
            let mobileHTML = `<div class="card-container display-mobile-only">`;
            
            personsWithData.forEach(person => {
                mobileHTML += `<div class="person-card-today card">`;
                mobileHTML += `<h3 class="person-header">${person}</h3>`;
                
                allPersonTodayReadings[person].forEach(reading => {
                    const sys = Number(reading.systole) || null;
                    const dia = Number(reading.diastole) || null;
                    const glu = Number(reading.glucose) || null;
                    const wei = Number(reading.weight) || null;

                    const bp = (sys !== null && dia !== null) ? `${sys}/${dia}` : '<span class="no-data">N/A</span>';
                    const glucose = glu !== null ? glu.toFixed(1) : '<span class="no-data">N/A</span>';
                    const weight = wei !== null ? wei.toFixed(1) : '<span class="no-data">N/A</span>';

                    mobileHTML += `
                        <div class="today-reading-block">
                            <span class="reading-time">${reading.time}</span>
                            <span class="value-prominent">BP: ${bp} | Gl: ${glucose} | W: ${weight}</span>
                            <div style="margin-top: 5px;">
                                <button class="action-btn edit-btn" onclick="editReading('${reading.id}')">‚úèÔ∏è Edit</button>
                                <button class="action-btn" onclick="deleteReading('${reading.id}')">‚ùå Delete</button>
                            </div>
                        </div>
                    `;
                });
                mobileHTML += `</div>`;
            });

            mobileHTML += `</div>`;
            
            container.innerHTML = contentHTML + desktopHTML + mobileHTML;
        }


        // --- DISPLAY 2: Overall Averages Summary (Table/Card) ---
        function displayAllAverages(allPersonAverages) {
            const container = document.getElementById('overallAveragesContainer');
            const personsWithData = Object.keys(allPersonAverages).filter(p => {
                const results = allPersonAverages[p];
                return results.systole.day.count > 0 || results.systole.week.count > 0 || results.systole.month.count > 0 || results.glucose.month.count > 0 || results.weight.month.count > 0;
            }).sort();
            
            const titleHTML = `<div style="display:flex; justify-content:space-between; align-items:center;"><h2>üìà Overall Averages Summary</h2><button class="table-export-btn" onclick="exportOverallAverages()">‚¨áÔ∏è Download Table (CSV)</button></div>`;

            if (personsWithData.length === 0) {
                container.innerHTML = titleHTML + `<p style="text-align:center; color:#777;">No readings available yet to calculate averages.</p>`;
                return;
            }

            // --- DESKTOP TABLE VIEW ---
            let desktopHTML = `<div class="display-desktop-only">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th rowspan="2">Person</th>
                            <th colspan="3">Blood Pressure (Sys/Dia mmHg)</th>
                            <th colspan="3">Glucose (mg/dL)</th>
                            <th colspan="3">Weight (kg/lbs)</th>
                        </tr>
                        <tr>
                            <th>Daily</th>
                            <th>Weekly</th>
                            <th>Monthly</th>
                            <th>Daily</th>
                            <th>Weekly</th>
                            <th>Monthly</th>
                            <th>Daily</th>
                            <th>Weekly</th>
                            <th>Monthly</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            personsWithData.forEach(person => {
                const results = allPersonAverages[person];
                
                desktopHTML += `
                    <tr>
                        <th>${person}</th>
                        <td>${formatBP(results.systole.day, results.diastole.day)}</td>
                        <td>${formatBP(results.systole.week, results.diastole.week)}</td>
                        <td>${formatBP(results.systole.month, results.diastole.month)}</td>
                        <td>${formatMetric(results.glucose.day)}</td>
                        <td>${formatMetric(results.glucose.week)}</td>
                        <td>${formatMetric(results.glucose.month)}</td>
                        <td>${formatMetric(results.weight.day)}</td>
                        <td>${formatMetric(results.weight.week)}</td>
                        <td>${formatMetric(results.weight.month)}</td>
                    </tr>
                `;
            });

            desktopHTML += `</tbody></table></div>`;
            
            // --- MOBILE CARD VIEW ---
            let mobileHTML = `<div class="card-container display-mobile-only">`;
            
            personsWithData.forEach(person => {
                const results = allPersonAverages[person];
                
                mobileHTML += `<div class="person-card-average card">
                    <h3>${person}</h3>
                    <div class="metric-group">
                        <span class="metric-label">Blood Pressure (Sys/Dia mmHg)</span>
                        <div class="data-point">Daily: <span class="reading-value">${formatBP(results.systole.day, results.diastole.day, true)}</span></div>
                        <div class="data-point">Weekly: <span class="reading-value">${formatBP(results.systole.week, results.diastole.week, true)}</span></div>
                        <div class="data-point">Monthly: <span class="reading-value">${formatBP(results.systole.month, results.diastole.month, true)}</span></div>
                    </div>
                    <div class="metric-group">
                        <span class="metric-label">Glucose (mg/dL)</span>
                        <div class="data-point">Daily: <span class="reading-value">${formatMetric(results.glucose.day, true)}</span></div>
                        <div class="data-point">Weekly: <span class="reading-value">${formatMetric(results.glucose.week, true)}</span></div>
                        <div class="data-point">Monthly: <span class="reading-value">${formatMetric(results.glucose.month, true)}</span></div>
                    </div>
                    <div class="metric-group">
                        <span class="metric-label">Weight (kg/lbs)</span>
                        <div class="data-point">Daily: <span class="reading-value">${formatMetric(results.weight.day, true)}</span></div>
                        <div class="data-point">Weekly: <span class="reading-value">${formatMetric(results.weight.week, true)}</span></div>
                        <div class="data-point">Monthly: <span class="reading-value">${formatMetric(results.weight.month, true)}</span></div>
                    </div>
                </div>`;
            });

            mobileHTML += `</div>`;
            
            container.innerHTML = titleHTML + desktopHTML + mobileHTML;
        }
        
        // --- DISPLAY 3: Detailed 30-Day History (Table/Card) ---
        function displayDetailedHistory(readingsByPerson) {
            const container = document.getElementById('detailedHistoryContainer');
            
            // 1. Determine the last 30 unique dates and generate latestReadingPerDay cache
            const uniqueDates = Array.from(new Set(allReadings.map(r => r.date)))
                .sort((a, b) => new Date(b) - new Date(a)) 
                .slice(0, 30); 
            
            detailedHistoryDataCache = {}; // Reset cache
            
            allReadings.forEach(r => {
                if (!r.person) return; 
                const key = `${r.date}_${r.person}`;
                // Only keep the latest reading of the day based on timestamp
                if (!detailedHistoryDataCache[key] || r.timestamp > detailedHistoryDataCache[key].timestamp) {
                    detailedHistoryDataCache[key] = r;
                }
            });

            const sortedPersonNames = Array.from(personNames).sort();
            
            const descriptionHTML = `<p style="text-align: center; font-style: italic; color: #555;">Showing the **latest recorded reading** for each person on a given day across the last 30 days.</p>`;
            const titleHTML = `<div style="display:flex; justify-content:space-between; align-items:center;"><h2>üìÖ Detailed 30-Day Reading History (Latest Reading/Day)</h2><button class="table-export-btn" onclick="exportDetailedHistory()">‚¨áÔ∏è Download Table (CSV)</button></div>`;

            if (personNames.size === 0 || uniqueDates.length === 0) {
                 container.innerHTML = titleHTML + descriptionHTML + `<p style="text-align:center; color:#777;">No history to display.</p>`;
                 return;
            }

            // --- DESKTOP TABLE VIEW ---
            let desktopHTML = `<div class="display-desktop-only">
                ${descriptionHTML}
                <table class="data-table">
                    <thead>
                        <tr>
                            <th rowspan="2">Date</th>
                            <th colspan="${sortedPersonNames.length * 3}" style="background-color: #11628e;">Readings by Person</th>
                        </tr>
                        <tr>
                            ${sortedPersonNames.map((name, index) => {
                                // Desktop header border
                                const style = index > 0 ? 'style="border-left: 2px solid #333; background-color: #007bff;"' : 'style="background-color: #007bff;"';
                                return `<th colspan="3" ${style}>${name}</th>`;
                            }).join('')}
                        </tr>
                        <tr>
                            <th style="font-size: 0.8em; color: #555;">(Latest to Oldest)</th>
                            ${sortedPersonNames.map(() => `
                                <th>BP</th>
                                <th>Glucose</th>
                                <th>Weight</th>
                            `).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            uniqueDates.forEach(date => {
                desktopHTML += `<tr><th>${formatDate(date)}</th>`;
                
                sortedPersonNames.forEach((person) => {
                    const key = `${date}_${person}`;
                    const r = detailedHistoryDataCache[key]; // Use the cached map
                    
                    if (r) {
                        const sys = Number(r.systole) || null;
                        const dia = Number(r.diastole) || null;
                        const glu = Number(r.glucose) || null;
                        const wei = Number(r.weight) || null;
                        
                        const bp = (sys !== null && dia !== null) ? `${sys}/${dia}` : `<span class="no-data">N/A</span>`;
                        const glucose = glu !== null ? glu.toFixed(1) : `<span class="no-data">N/A</span>`;
                        const weight = wei !== null ? wei.toFixed(1) : `<span class="no-data">N/A</span>`;
                        
                        desktopHTML += `
                            <td class="detail-reading">${bp}</td>
                            <td class="detail-reading">${glucose}</td>
                            <td class="detail-reading">${weight}</td>
                        `;
                    } else {
                        desktopHTML += `
                            <td colspan="3"><span class="no-data">-</span></td>
                        `;
                    }
                });
                
                desktopHTML += `</tr>`;
            });

            desktopHTML += `</tbody></table></div>`;
            
            // --- MOBILE CARD VIEW ---
            let mobileHTML = `<div class="card-container display-mobile-only">`;

            uniqueDates.forEach(date => {
                // Date-wise Bifurcation
                mobileHTML += `<div class="date-header">${formatDate(date)}</div>`;
                
                sortedPersonNames.forEach((person) => {
                    const key = `${date}_${person}`;
                    const r = detailedHistoryDataCache[key];
                    
                    if (r) {
                        const sys = Number(r.systole) || null;
                        const dia = Number(r.diastole) || null;
                        const glu = Number(r.glucose) || null;
                        const wei = Number(r.weight) || null;
                        
                        const bp = (sys !== null && dia !== null) ? `${sys}/${dia}` : `<span class="no-data">N/A</span>`;
                        const glucose = glu !== null ? glu.toFixed(1) : `<span class="no-data">N/A</span>`;
                        const weight = wei !== null ? wei.toFixed(1) : `<span class="no-data">N/A</span>`;
                        
                        // Person-wise Card
                        mobileHTML += `<div class="person-card-detailed">
                            <div class="person-header">${person}</div>
                            <div class="reading-row">BP: <span class="reading-value">${bp}</span></div>
                            <div class="reading-row">Glucose: <span class="reading-value">${glucose}</span></div>
                            <div class="reading-row">Weight: <span class="reading-value">${weight}</span></div>
                        </div>`;
                    }
                    // Skip if no reading for person/date
                });
            });

            mobileHTML += `</div>`;


            container.innerHTML = titleHTML + desktopHTML + mobileHTML;
        }

        // --- EXPORT FUNCTIONALITY (CSV/Excel) - Unchanged ---
        
        // UTILITY: General CSV Download Function
        function triggerDownload(csvContent, filename) {
            if (!csvContent || csvContent.length < 50) { // Simple check for empty/short content
                alert("No data available to export for this view.");
                return;
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            alert(`Successfully generated CSV file: ${filename}`);
        }

        // EXPORT 1: Full History Download
        function exportFullHistory() {
            if (allReadings.length === 0) {
                alert("No history data available to export.");
                return;
            }

            // 1. Prepare CSV Header
            let csvContent = "Date,Time,Person,Systolic (mmHg),Diastolic (mmHg),Glucose (mg/dL),Weight (kg/lbs)\n";

            // 2. Sort readings by date/time ascending for logical export order
            const sortedForExport = [...allReadings].sort((a, b) => {
                const dateA = new Date(a.date + ' ' + (a.time || '00:00'));
                const dateB = new Date(b.date + ' ' + (b.time || '00:00'));
                return dateA - dateB; 
            });
            
            // 3. Populate CSV Rows
            sortedForExport.forEach(r => {
                const date = r.date || '';
                const time = r.time || '';
                // Use quotes around the person's name just in case it contains commas
                const person = r.person ? `"${r.person.replace(/"/g, '""')}"` : ''; 
                // Ensure null values are represented as empty strings in CSV
                const systole = r.systole !== null && r.systole !== undefined ? r.systole : '';
                const diastole = r.diastole !== null && r.diastole !== undefined ? r.diastole : '';
                const glucose = r.glucose !== null && r.glucose !== undefined ? r.glucose : '';
                const weight = r.weight !== null && r.weight !== undefined ? r.weight : '';

                csvContent += `${date},${time},${person},${systole},${diastole},${glucose},${weight}\n`;
            });

            const timestamp = new Date().toISOString().slice(0, 10);
            triggerDownload(csvContent, `Health_Readings_Full_Export_${timestamp}.csv`);
        }

        // EXPORT 2: Overall Averages Download
        function exportOverallAverages() {
            if (Object.keys(allPersonAveragesCache).length === 0) {
                alert("No averages available to export.");
                return;
            }

            let csvContent = "Person,Daily BP (Sys/Dia),Daily Glucose,Daily Weight,Weekly BP (Sys/Dia),Weekly Glucose,Weekly Weight,Monthly BP (Sys/Dia),Monthly Glucose,Monthly Weight\n";
            
            const personsWithData = Object.keys(allPersonAveragesCache).sort();
            
            personsWithData.forEach(person => {
                const results = allPersonAveragesCache[person];
                
                // Helper to get formatted average or empty string
                const getAvg = (data) => data.avg !== null ? data.avg.toFixed(1) : '';
                const getBP = (sys, dia) => {
                    if (sys.avg !== null && dia.avg !== null) {
                        return `${sys.avg.toFixed(0)}/${dia.avg.toFixed(0)}`;
                    }
                    return '';
                };
                
                const dailyBP = getBP(results.systole.day, results.diastole.day);
                const dailyGlucose = getAvg(results.glucose.day);
                const dailyWeight = getAvg(results.weight.day);

                const weeklyBP = getBP(results.systole.week, results.diastole.week);
                const weeklyGlucose = getAvg(results.glucose.week);
                const weeklyWeight = getAvg(results.weight.week);

                const monthlyBP = getBP(results.systole.month, results.diastole.month);
                const monthlyGlucose = getAvg(results.glucose.month);
                const monthlyWeight = getAvg(results.weight.month);

                // Use quotes around the person's name
                const escapedPerson = `"${person.replace(/"/g, '"""')}"`;

                csvContent += `${escapedPerson},${dailyBP},${dailyGlucose},${dailyWeight},${weeklyBP},${weeklyGlucose},${weeklyWeight},${monthlyBP},${monthlyGlucose},${monthlyWeight}\n`;
            });
            
            const timestamp = new Date().toISOString().slice(0, 10);
            triggerDownload(csvContent, `Overall_Averages_Export_${timestamp}.csv`);
        }

        // EXPORT 3: Detailed 30-Day History Download
        function exportDetailedHistory() {
            const uniqueDates = Array.from(new Set(allReadings.map(r => r.date)))
                .sort((a, b) => new Date(b) - new Date(a)) 
                .slice(0, 30); 
            const sortedPersonNames = Array.from(personNames).sort();
            
            if (uniqueDates.length === 0 || sortedPersonNames.length === 0) {
                alert("No detailed history data available to export.");
                return;
            }

            // 1. Prepare Header
            let header1 = "Date,";
            header1 += sortedPersonNames.map(name => `"${name} BP","${name} Glucose","${name} Weight"`).join(',') + "\n";
            let csvContent = header1;

            // 2. Populate Rows
            uniqueDates.forEach(date => {
                let row = `"${formatDate(date)}",`;
                
                sortedPersonNames.forEach(person => {
                    const key = `${date}_${person}`;
                    const r = detailedHistoryDataCache[key];
                    
                    if (r) {
                        // Ensure null values are empty strings in CSV
                        const sys = r.systole !== null && r.systole !== undefined ? r.systole : '';
                        const dia = r.diastole !== null && r.diastole !== undefined ? r.diastole : '';
                        const glu = r.glucose !== null && r.glucose !== undefined ? r.glucose : '';
                        const wei = r.weight !== null && r.weight !== undefined ? r.weight : '';
                        
                        // BP is separated into two columns in the raw data, but combined here for the "BP" column
                        const bp = (sys !== '' && dia !== '') ? `${sys}/${dia}` : '';
                        row += `${bp},${glu},${wei},`;
                    } else {
                        row += `,,,\n`; // 3 empty commas for N/A
                    }
                });
                
                // Trim trailing comma if any
                if (row.endsWith(',')) row = row.slice(0, -1);
                csvContent += row + "\n";
            });

            const timestamp = new Date().toISOString().slice(0, 10);
            triggerDownload(csvContent, `Detailed_History_Export_${timestamp}.csv`);
        }
        
        // Initial setup on resize to re-render views if necessary
        window.addEventListener('resize', loadReadings);
        // Clean up on unmount (important for single-page apps, but good practice)
        window.addEventListener('beforeunload', () => {
             window.removeEventListener('resize', loadReadings);
        });

    </script>
</body>
</html>
