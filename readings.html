<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holistic Health Tracker (BP/Glucose)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
    <style>
        /* Global & Reset */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1200px; 
            margin: 0 auto;
            background-color: #f7f9fc;
        }

        h1 {
            color: #1a4f78;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        /* Controls and Inputs */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        .controls label {
            font-weight: bold;
            display: block;
            margin-top: 5px;
            color: #555;
            margin-bottom: 5px;
        }
        
        .controls input[type="date"],
        .controls input[type="time"],
        .controls input[type="number"],
        .controls input[type="text"],
        .controls select,
        #personSelect {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        /* GRID FIXES for Alignment */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
            align-items: start;
        }
        
        /* Person Input Group Styling */
        .person-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #personCustomInput {
            margin-top: 0;
            display: none;
        }

        /* Buttons */
        button {
            padding: 10px 20px;
            margin-top: 10px;
            cursor: pointer;
            font-size: 16px;
            border: none;
            border-radius: 4px;
        }

        .add {
            background: #4CAF50;
            color: white;
        }
        
        .update {
            background: #FF9800; /* Orange for Update */
            color: white;
            display: none; /* Hidden by default */
        }
        
        /* New Table Download Button Style */
        .table-export-btn {
            background: #2196F3; /* Light Blue for table export */
            color: white;
            padding: 8px 15px;
            font-size: 14px;
            margin-top: 10px;
            float: right;
            white-space: nowrap;
        }
        
        .export-btn {
            background: #007bff; /* Blue for full export */
            color: white;
            margin-top: 15px;
        }

        .logout-btn {
            background: #f44336;
            color: white;
            padding: 5px 15px;
            font-size: 14px;
        }
        
        /* --- TABLES STYLES (Applies to all new tables) --- */
        #overallAveragesContainer, #todayAveragesContainer, #detailedHistoryContainer {
            margin-top: 30px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            /* Remove overflow-x: auto; here to force responsive behavior */
        }

        .data-table {
            width: 100%;
            min-width: 0; /* Important for mobile wrap */
            border-collapse: collapse;
            margin-top: 15px;
        }

        .data-table th, .data-table td {
            padding: 12px 10px;
            border: 1px solid #eee;
            text-align: center;
            font-size: 0.9em; 
        }
        
        .data-table thead th {
            background-color: #1a4f78; 
            color: white;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .data-table thead tr:nth-child(2) th {
            background-color: #007bff; /* Blue secondary header */
            color: white;
        }

        .data-table tbody th {
            text-align: left;
            background-color: #f0f8ff; 
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f7f9fc;
        }

        .avg-bp, .avg-reading {
            white-space: nowrap;
            font-weight: bold;
        }
        
        .no-data {
            color: #999;
            font-style: italic;
        }
        
        /* Increased font size for Today's individual readings */
        #todayAveragesContainer .detail-reading {
            font-size: 1.0em; 
        }

        /* Auth Styles */
        #authContainer {
            max-width:400px; margin:50px auto; padding:30px; background:#f9f9f9; border-radius:10px;
        }
        .signup-fields { display: none; }
        #authContainer.signup-mode .signup-fields { display: block; }
        
        /* New MFA Styles */
        #mfaContainer {
            max-width:400px; margin:50px auto; padding:30px; background:#f9f9f9; border-radius:10px;
            display: none; /* Hidden by default */
        }
        /* NEW ENROLLMENT STYLES */
        #enrollMfaContainer {
            max-width:400px; margin:50px auto; padding:30px; background:#fff3e0; border-radius:10px;
            display: none; /* Hidden by default */
        }
        /* ----------------------- */
        #recaptcha-container {
            /* Hide the reCAPTCHA box if using 'invisible' size */
            margin-top: 10px;
        }

        /* Navigation Link Style */
        .nav-link {
            text-decoration: none;
            color: white;
            font-weight: bold;
            margin-left: 15px;
            padding: 8px 12px;
            border-radius: 4px;
            background: #2196F3;
            transition: background 0.2s;
        }
        .nav-link:hover {
            background: #0d47a1;
        }
        /* Action Buttons within Tables */
        .action-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .edit-btn {
            background-color: #4CAF50; /* Green for Edit */
        }
        .action-btn:hover {
            opacity: 0.8;
        }
        
        /* --- MOBILE RESPONSIVENESS: CARD/LIST VIEW --- */
        @media screen and (max-width: 768px) {
            
            /* General Layout Adjustments */
            body { padding: 10px; }
            .input-grid { grid-template-columns: 1fr; } /* Stack input fields */

            /* Table Wrapper - Ensure tables don't force a scroll */
            #overallAveragesContainer, #detailedHistoryContainer {
                padding: 10px;
            }

            /* Hiding Headers and Reformatting */
            .data-table {
                border: 0;
            }
            .data-table thead, .data-table thead tr {
                position: absolute;
                width: 1px;
                height: 1px;
                padding: 0;
                margin: -1px;
                overflow: hidden;
                clip: rect(0, 0, 0, 0);
                border: 0;
            }

            /* Transform rows into cards */
            .data-table tr {
                display: block;
                margin-bottom: 15px;
                border: 1px solid #ccc;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                background-color: #fff;
            }
            
            /* Treat Person/Date header rows specially */
            .data-table tbody th {
                display: block;
                text-align: center;
                border: none;
                border-bottom: 1px solid #ccc;
                background-color: #1a4f78;
                color: white;
                font-size: 1.1em;
                padding: 10px;
                border-radius: 8px 8px 0 0;
            }
            
            /* Transform cells into block-level elements */
            .data-table td {
                display: block;
                text-align: right;
                border: none;
                border-bottom: 1px dotted #ddd;
                position: relative;
                padding-left: 50%; /* Make room for the pseudo-element label */
            }

            /* Insert the original header content as a label using data-label attribute */
            .data-table td::before {
                content: attr(data-label) ":";
                position: absolute;
                left: 10px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                text-align: left;
                font-weight: bold;
                color: #555;
            }
            
            .data-table tr:nth-child(even) {
                background-color: #fff; /* Reset zebra striping for cards */
            }
            
            /* Today's Readings Table Specific adjustments (less severe transformation) */
            /* Since the first column is TIME, we'll hide the person header row and stack time/reading */
            #todayAveragesContainer .data-table {
                 min-width: unset;
            }
            #todayAveragesContainer .data-table thead tr:nth-child(1) th {
                display: none; /* Hide the Time header */
            }
            #todayAveragesContainer .data-table thead tr:nth-child(2) th {
                 display: none; /* Hide the Person Name headers */
            }
            #todayAveragesContainer .data-table tbody tr {
                border: none;
                box-shadow: none;
                margin-bottom: 0;
                display: flex; /* Make row a flex container */
                flex-wrap: wrap;
                border-bottom: 1px solid #e0e0e0;
                padding: 10px 0;
                background-color: transparent !important;
            }
            #todayAveragesContainer .data-table tbody th {
                /* Time column */
                flex: 0 0 100%;
                text-align: left;
                background-color: transparent;
                color: #1a4f78;
                border: none;
                font-size: 1.1em;
                padding: 5px 10px;
                border-bottom: 1px solid #ccc;
            }
            #todayAveragesContainer .data-table tbody td {
                /* Reading data cells */
                flex: 1 1 50%; /* Allow 2 columns of readings per row */
                text-align: left;
                padding-left: 10px;
                border: none;
                border-bottom: none;
                min-width: 50%;
            }
            #todayAveragesContainer .data-table tbody td:before {
                content: attr(data-person) ":"; /* Use person name as label */
                position: static;
                width: auto;
                padding-right: 5px;
                font-weight: normal;
                color: #1a4f78;
            }
            #todayAveragesContainer .detail-reading {
                display: block;
                line-height: 1.4;
            }
            .action-btn {
                margin-top: 5px;
                margin-right: 5px;
            }

        }
    </style>
</head>
<body>
    <div id="authContainer" style="display:none;">
        <h2>üîí Health Tracker Access</h2>
        <div style="margin:20px 0;">
            <div class="signup-fields">
                <input type="text" id="name" placeholder="Your Name" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            </div>
            <input type="email" id="email" placeholder="Email" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            <input type="password" id="password" placeholder="Password (min 6 chars)" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            <div class="signup-fields">
                <input type="password" id="confirmPassword" placeholder="Confirm Password" style="width:100%; padding:10px; margin:5px 0; box-sizing:border-box;">
            </div>
        </div>
        <button class="add" onclick="login()" style="width:48%; margin:2%;" id="loginBtn">Login</button>
        <button class="export" onclick="toggleSignupMode()" style="width:48%; margin:2%;" id="signupToggleBtn">Sign Up</button>
        <div id="authError" style="color:red; margin-top:10px;"></div>
        <div id="recaptcha-container"></div> 
    </div>
    
    <div id="mfaContainer">
        <h2>üîë Two-Factor Verification</h2>
        <p id="mfaInstructions" style="color:#555;"></p>
        <input type="text" id="mfaSmsCode" placeholder="Enter SMS Code" style="width:100%; padding:10px; margin:10px 0; box-sizing:border-box;">
        <button class="add" onclick="resolveMfaLogin(document.getElementById('mfaSmsCode').value)" style="width:100%;">Verify and Login</button>
        <div id="mfaError" style="color:red; margin-top:10px;"></div>
    </div>

    <div id="enrollMfaContainer" style="display:none; max-width:400px; margin:50px auto; padding:30px; background:#fff3e0; border-radius:10px;">
        <h2>‚ö†Ô∏è Security Setup Required</h2>
        <p style="color:#e65100;">For your security, we need to enroll a phone number to enable two-factor verification. This is a one-time setup.</p>
        <input type="text" id="enrollPhoneNumber" placeholder="Phone Number (e.g., +15555550100)" style="width:100%; padding:10px; margin:10px 0; box-sizing:border-box;">
        <button class="add" onclick="startMfaEnrollment()" style="width:100%; background: #e65100;">Send Verification Code</button>
        <div id="enrollError" style="color:red; margin-top:10px;"></div>
    </div>
    <div id="appContainer" style="display:none;">
        <div style="text-align:right; margin-bottom:20px; display:flex; justify-content:flex-end; align-items:center;">
            <a href="index.html" class="nav-link">üíä Medicine Tracker</a>
            
            <span id="userEmail" style="margin-right:10px; font-weight:bold; margin-left: 15px;"></span>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
        
        <h1>‚ù§Ô∏è Daily Health Readings</h1>
        
        <div class="controls">
            <h2>Record a New Reading</h2>
            <div class="input-grid">
                <input type="hidden" id="readingIdToEdit" value="">
                
                <div class="input-group">
                    <label for="recordDate">Date</label>
                    <input type="date" id="recordDate">
                </div>
                
                <div class="input-group">
                    <label for="recordTime">Time</label>
                    <input type="time" id="recordTime">
                </div>

                <div class="input-group">
                    <label for="personSelect">Person Name</label>
                    <div class="person-input-group">
                        <select id="personSelect" onchange="handlePersonChange(this.value)">
                            <option value="" disabled selected>Select a person...</option>
                            <option value="Custom">Add New Person...</option>
                        </select>
                        <input type="text" id="personCustomInput" placeholder="Enter new name here" onblur="handleCustomNameBlur(this.value)">
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="systole">Systolic (BP)</label>
                    <input type="number" id="systole" placeholder="e.g., 120" step="1">
                </div>
                
                <div class="input-group">
                    <label for="diastole">Diastolic (BP)</label>
                    <input type="number" id="diastole" placeholder="e.g., 80" step="1">
                </div>

                <div class="input-group">
                    <label for="glucose">Glucose (mg/dL)</label>
                    <input type="number" id="glucose" placeholder="e.g., 100" step="0.1">
                </div>

                <div class="input-group">
                    <label for="weight">Weight (kg/lbs)</label>
                    <input type="number" id="weight" placeholder="e.g., 75" step="0.1">
                </div>
                
            </div>
            
            <button class="add" id="addButton" onclick="addReading()">Add Reading</button>
            <button class="update" id="updateButton" onclick="updateReading()">Update Reading</button>
            
            <button class="export-btn" onclick="exportFullHistory()">‚¨áÔ∏è Download Full History (CSV)</button>

        </div>
        
        <div id="todayAveragesContainer">
            <h2>‚òÄÔ∏è Today's Individual Readings</h2> 
            </div>

        <div id="detailedHistoryContainer">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2>üìÖ Detailed 30-Day Reading History (Latest Reading/Day)</h2>
                <button class="table-export-btn" onclick="exportDetailedHistory()">‚¨áÔ∏è Download Table (CSV)</button>
            </div>
            <p style="text-align: center; font-style: italic; color: #555;">Showing the **latest recorded reading** for each person on a given day across the last 30 days. For a full export, please use the download button above.</p>
            </div>

        <div id="overallAveragesContainer">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2>üìà Overall Averages Summary</h2>
                <button class="table-export-btn" onclick="exportOverallAverages()">‚¨áÔ∏è Download Table (CSV)</button>
            </div>
            </div>

    </div>

    <script type="module">
        // Make functions global for inline onclick handlers
        window.login = login;
        window.signup = signup;
        window.logout = logout;
        window.toggleSignupMode = toggleSignupMode; 
        window.handlePersonChange = handlePersonChange;
        window.handleCustomNameBlur = handleCustomNameBlur; 
        window.addReading = addReading;
        window.updateReading = updateReading; 
        window.editReading = editReading;   
        window.deleteReading = deleteReading;
        window.loadReadings = loadReadings; 
        window.exportFullHistory = exportFullHistory; 
        window.exportDetailedHistory = exportDetailedHistory; 
        window.exportOverallAverages = exportOverallAverages; 
        
        // --- NEW MFA GLOBAL FUNCTIONS ---
        window.resolveMfaLogin = resolveMfaLogin;
        // NEW FUNCTIONS FOR ENROLLMENT
        window.startMfaEnrollment = startMfaEnrollment;
        window.completeMfaEnrollment = completeMfaEnrollment;


        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, update, remove } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-database.js';
        
        // --- UPDATED AUTH IMPORTS FOR MFA ---
        import { 
            getAuth, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut,
            PhoneAuthProvider, // New
            multiFactor // New
        } from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-auth.js';
        // Need to import the standard namespace for RecaptchaVerifier
        import firebase from 'https://www.gstatic.com/firebasejs/9.21.0/firebase-auth-compat.js'; 


        // Your web app's Firebase configuration (CONFIRMED)
        const firebaseConfig = {
            apiKey: "AIzaSyAjRB8_dLv8icceOyZNNGO9kIXUFVjWfoY",
            authDomain: "medicine-tracker-b90f2.firebaseapp.com",
            databaseURL: "https://medicine-tracker-b90f2-default-rtdb.firebaseio.com",
            projectId: "medicine-tracker-b90f2",
            storageBucket: "medicine-tracker-b90f2.firebasestorage.app",
            messagingSenderId: "230127910329",
            appId: "1:230127910329:web:756789fcd3a1ac02948a68"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        let currentUser = null;
        let allReadings = [];
        let allPersonAveragesCache = {}; // Cache for overall averages
        let detailedHistoryDataCache = {}; // Cache for detailed history data
        let personNames = new Set();
        let currentPerson = '';
        const today = new Date();
        document.getElementById('recordDate').value = today.toISOString().split('T')[0];
        document.getElementById('recordTime').value = today.toTimeString().split(' ')[0].substring(0, 5); 
        const todayDateString = today.toISOString().split('T')[0];

        // --- NEW MFA VARIABLES ---
        let recaptchaVerifier = null;
        let mfaResolver = null; // Stores the object needed to complete the 2FA login
        let verificationId = null; // Stores the ID needed to verify the SMS code
        let enrollmentSession = null; // NEW: Stores the session for new enrollment

        // --- NEW: Setup Invisible reCAPTCHA ---
        function setupRecaptcha() {
            if (recaptchaVerifier) return;
            
            // ReCAPTCHA requires the standard Firebase namespace, which we imported as 'firebase'
            recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container', {
                'size': 'invisible', 
                'callback': (response) => {
                    // reCAPTCHA solved automatically in invisible mode
                },
                'expired-callback': () => {
                    document.getElementById('authError').textContent = 'reCAPTCHA expired. Please refresh.';
                }
            }, auth);

            // Render the reCAPTCHA widget
            recaptchaVerifier.render();
        }


        // --- UTILITY: Date Formatting (DD-MMM-YY) ---
        function formatDate(dateString) {
            if (!dateString) return '';
            // Use date only part to prevent timezone shift issues on Date object creation
            const date = new Date(dateString + 'T00:00:00'); 
            
            const day = date.getDate().toString().padStart(2, '0');
            const year = date.getFullYear().toString().slice(-2);
            
            const monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            const month = monthNames[date.getMonth()];

            return `${day}-${month}-${year}`;
        }
        
        // --- AUTH & SYNC ---
        function toggleSignupMode() {
            const container = document.getElementById('authContainer');
            const toggleBtn = document.getElementById('signupToggleBtn');
            const loginBtn = document.getElementById('loginBtn');
            const isSignupMode = container.classList.contains('signup-mode');

            if (isSignupMode) {
                container.classList.remove('signup-mode');
                toggleBtn.textContent = 'Sign Up';
                toggleBtn.onclick = toggleSignupMode;
                loginBtn.onclick = login;
            } else {
                container.classList.add('signup-mode');
                toggleBtn.textContent = 'Register';
                toggleBtn.onclick = signup;
                loginBtn.onclick = () => { container.classList.remove('signup-mode'); login(); };
            }
            document.getElementById('authError').textContent = '';
        }

        // --- MODIFIED LOGIN FUNCTION FOR MFA HANDLING ---
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorEl = document.getElementById('authError');
            errorEl.textContent = '';
            
            if (!email || !password) { errorEl.textContent = 'Please enter email and password'; return; }
            
            try {
                // 1. Initial Sign-in Attempt
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                
                // Success: If no MFA required, proceed normally
                currentUser = userCredential.user;
                showApp(); // <-- Now checks for enrollment

            } catch (error) {
                
                // 2. Catch the MultiFactor Auth Exception
                if (error.code === 'auth/multi-factor-auth-required') {
                    
                    // Step A: Store the resolver object (required to finish login)
                    mfaResolver = error.resolver;
                    // Get the first available factor (the phone number)
                    const phoneFactor = mfaResolver.hints[0]; 
                    
                    // Step B: Start the second factor verification (sends SMS)
                    const phoneAuthCredential = PhoneAuthProvider.credentialWithSession(mfaResolver.session, phoneFactor.phoneNumber);
                    
                    // Step C: Verify the phone number (sends SMS and uses reCAPTCHA)
                    verificationId = await PhoneAuthProvider.verifyPhoneNumber(
                        phoneAuthCredential,
                        recaptchaVerifier 
                    );
                    
                    // UI Change: Hide password container, show MFA container
                    document.getElementById('authContainer').style.display = 'none';
                    document.getElementById('mfaContainer').style.display = 'block';
                    document.getElementById('mfaInstructions').textContent = `Code sent to ${phoneFactor.phoneNumber}. Please enter it below.`;
                    document.getElementById('mfaError').textContent = '';
                    
                } else {
                    // Handle standard login errors (wrong password, etc.)
                    errorEl.textContent = 'Login failed: ' + error.message;
                }
            }
        }
        
        // --- Function to Resolve the MFA Login after SMS Code is Entered ---
        async function resolveMfaLogin(smsCode) {
            const errorEl = document.getElementById('mfaError');
            errorEl.textContent = '';
            
            if (!mfaResolver || !verificationId || !smsCode) { 
                errorEl.textContent = 'Verification process interrupted. Please try logging in again.';
                return; 
            }

            try {
                // 1. Create the Phone Auth Credential using the received SMS code
                const phoneAuthCredential = PhoneAuthProvider.credential(
                    verificationId, 
                    smsCode
                );

                // 2. Resolve the multi-factor sign-in
                const userCredential = await mfaResolver.resolveSignIn(phoneAuthCredential);
                
                // Success: Finish login
                currentUser = userCredential.user;
                
                // UI Change: Hide MFA form, show the main app container
                document.getElementById('mfaContainer').style.display = 'none';
                showApp();

                // Clear temporary state
                mfaResolver = null;
                verificationId = null;

            } catch (error) {
                console.error("MFA Login Resolution Failed:", error);
                errorEl.textContent = "2FA code incorrect or expired. Please check the code and try again.";
            }
        }
        
        // --- NEW: START MFA ENROLLMENT (Sends SMS to new number) ---
        async function startMfaEnrollment() {
            const phoneNumber = document.getElementById('enrollPhoneNumber').value;
            const errorEl = document.getElementById('enrollError');
            errorEl.textContent = '';
            
            // Firebase expects phone numbers to be in E.164 format (e.g., +15551234567)
            const phoneRegex = /^\+[1-9]\d{1,14}$/;
            if (!phoneNumber || !currentUser || !phoneRegex.test(phoneNumber)) {
                errorEl.textContent = 'Please enter a valid phone number, including country code (e.g., +15551234567).';
                return;
            }

            try {
                // 1. Start the MFA enrollment process for the current user
                enrollmentSession = await multiFactor(currentUser).startEnrollment(
                    {
                        phoneNumber: phoneNumber,
                    },
                    recaptchaVerifier
                );
                
                // 2. UI Change: Hide enrollment form, show MFA code form
                document.getElementById('enrollMfaContainer').style.display = 'none';
                document.getElementById('mfaContainer').style.display = 'block';
                document.getElementById('mfaInstructions').textContent = `Verification code sent to ${phoneNumber}. Please enter it to complete security setup.`;
                
                // Change the button action to the final completion step
                document.querySelector('#mfaContainer button').onclick = () => completeMfaEnrollment(document.getElementById('mfaSmsCode').value);

            } catch (error) {
                console.error("MFA Enrollment Failed:", error);
                errorEl.textContent = "Failed to send code: " + error.message;
            }
        }

        // --- NEW: COMPLETE MFA ENROLLMENT (Verifies SMS code) ---
        async function completeMfaEnrollment(smsCode) {
            const errorEl = document.getElementById('mfaError');
            errorEl.textContent = '';
            
            if (!enrollmentSession || !smsCode) {
                errorEl.textContent = 'Verification process interrupted. Please try again.';
                return;
            }

            try {
                // 1. Build the Phone Auth Credential using the session and SMS code
                const phoneAuthCredential = PhoneAuthProvider.credential(
                    enrollmentSession,
                    smsCode
                );

                // 2. Enroll the second factor to the user's account
                await multiFactor(currentUser).enroll(phoneAuthCredential);

                // Success: The user now has a phone number enrolled.
                // Reset the state
                enrollmentSession = null;
                document.getElementById('mfaSmsCode').value = '';
                
                // Restore the MFA button's original login function
                document.querySelector('#mfaContainer button').onclick = () => resolveMfaLogin(document.getElementById('mfaSmsCode').value);

                // Finally, show the main app
                showApp();

            } catch (error) {
                console.error("MFA Enrollment Completion Failed:", error);
                errorEl.textContent = "Verification failed: " + error.message + ". Please try again.";
            }
        }
        
        // --- End of new MFA functions ---


        function signup() {
            const name = document.getElementById('name').value;
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            const errorEl = document.getElementById('authError');

            if (!name || !email || !password || !confirmPassword || password !== confirmPassword) {
                errorEl.textContent = 'Please check all fields and ensure passwords match.';
                return;
            }

            createUserWithEmailAndPassword(auth, email, password)
                .then((userCredential) => {
                    currentUser = userCredential.user;
                    const userRef = ref(db, 'users/' + currentUser.uid + '/profile');
                    set(userRef, { name: name, email: email })
                        .then(() => showApp()); // <-- Will check for enrollment
                })
                .catch((error) => {
                    errorEl.textContent = 'Signup failed: ' + error.message;
                });
        }

        function logout() {
            if (confirm('Logout?')) {
                signOut(auth).then(() => {
                    currentUser = null;
                    showLogin();
                });
            }
        }

        function showLogin() {
            document.getElementById('authContainer').style.display = 'block';
            document.getElementById('mfaContainer').style.display = 'none'; // Ensure MFA is hidden
            document.getElementById('enrollMfaContainer').style.display = 'none'; // Ensure enrollment is hidden
            document.getElementById('appContainer').style.display = 'none';
            setupRecaptcha(); // Set up reCAPTCHA when showing the login form
        }

        // --- MODIFIED SHOWAPP FUNCTION TO CHECK FOR ENROLLMENT ---
        async function showApp() {
            if (!currentUser) { return; }

            try {
                // 1. Check if the user has any MFA factor enrolled
                const enrolledFactors = await multiFactor(currentUser).getEnrolledFactors();
                
                if (enrolledFactors.length === 0) {
                    // 2. NO PHONE NUMBER ENROLLED: Show the enrollment form
                    document.getElementById('authContainer').style.display = 'none';
                    document.getElementById('mfaContainer').style.display = 'none';
                    document.getElementById('appContainer').style.display = 'none';
                    document.getElementById('enrollMfaContainer').style.display = 'block';
                    return; // STOP here, the user must enroll a phone number
                }

                // 3. ENROLLMENT COMPLETE or MFA NOT MANDATORY: Show the main app
                document.getElementById('authContainer').style.display = 'none';
                document.getElementById('mfaContainer').style.display = 'none';
                document.getElementById('enrollMfaContainer').style.display = 'none';
                document.getElementById('appContainer').style.display = 'block';

                const profileRef = ref(db, 'users/' + currentUser.uid + '/profile/name');
                onValue(profileRef, (snapshot) => {
                    const userName = snapshot.val();
                    document.getElementById('userEmail').textContent = userName || currentUser.email;
                }, { onlyOnce: true });
        
                setupRealtimeSync();

            } catch (error) {
                console.error("Error checking MFA status:", error);
                // Fallback to show login or a generic error
                showLogin();
            }
        }
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                showApp();
            } else {
                currentUser = null;
                showLogin();
            }
        });

        let syncListener = null;
        function setupRealtimeSync() {
            if (!currentUser) return;
            if (syncListener) syncListener(); 

            // Path check is critical
            const readingsRef = ref(db, 'users/' + currentUser.uid + '/healthReadings');

            syncListener = onValue(readingsRef, (snapshot) => {
                const data = snapshot.val(); 
                allReadings = [];
                personNames.clear();

                if (data) {
                    for (const key in data) {
                        const reading = { id: key, ...data[key] };
                        allReadings.push(reading);
                        if (reading.person) {
                            personNames.add(reading.person);
                        }
                    }
                }
                // Sort by date and then time descending
                allReadings.sort((a, b) => {
                    // Normalize time to handle potential undefined fields
                    const dateA = new Date(a.date + ' ' + (a.time || '00:00'));
                    const dateB = new Date(b.date + ' ' + (b.time || '00:00'));
                    return dateB - dateA;
                });
                
                loadReadings(); 
                populatePersonSelect(); 
                calculateAndDisplayAverages();
                displayDetailedHistory();
            });
        }

        // --- CRUD Operations ---
        function addReading() {
            const date = document.getElementById('recordDate').value;
            const time = document.getElementById('recordTime').value;
            let person = document.getElementById('personSelect').value;
            const systole = document.getElementById('systole').value;
            const diastole = document.getElementById('diastole').value;
            const glucose = document.getElementById('glucose').value;
            const weight = document.getElementById('weight').value;

            if (person === 'Custom') {
                person = document.getElementById('personCustomInput').value.trim();
            }
            if (!date || !time || !person) {
                alert("Please fill in Date, Time, and Person Name.");
                return;
            }

            const newReading = {
                date: date,
                time: time,
                person: person,
                systole: systole ? parseFloat(systole) : null,
                diastole: diastole ? parseFloat(diastole) : null,
                glucose: glucose ? parseFloat(glucose) : null,
                weight: weight ? parseFloat(weight) : null,
                timestamp: new Date(date + 'T' + time).getTime()
            };

            const readingsRef = ref(db, 'users/' + currentUser.uid + '/healthReadings');
            push(readingsRef, newReading)
                .then(() => {
                    // Clear form after successful push
                    document.getElementById('systole').value = '';
                    document.getElementById('diastole').value = '';
                    document.getElementById('glucose').value = '';
                    document.getElementById('weight').value = '';
                    document.getElementById('personSelect').value = '';
                    document.getElementById('personCustomInput').value = '';
                    document.getElementById('personCustomInput').style.display = 'none';

                    // Re-set date/time to now for convenience
                    const now = new Date();
                    document.getElementById('recordDate').value = now.toISOString().split('T')[0];
                    document.getElementById('recordTime').value = now.toTimeString().split(' ')[0].substring(0, 5);
                })
                .catch(error => {
                    alert("Failed to add reading: " + error.message);
                });
        }

        function editReading(id) {
            const reading = allReadings.find(r => r.id === id);
            if (!reading) return;

            // 1. Fill form fields
            document.getElementById('readingIdToEdit').value = reading.id;
            document.getElementById('recordDate').value = reading.date;
            document.getElementById('recordTime').value = reading.time || '';
            document.getElementById('systole').value = reading.systole || '';
            document.getElementById('diastole').value = reading.diastole || '';
            document.getElementById('glucose').value = reading.glucose || '';
            document.getElementById('weight').value = reading.weight || '';

            // 2. Handle person selection
            populatePersonSelect(reading.person); // Ensure the option exists and is selected
            document.getElementById('personCustomInput').style.display = 'none';

            // 3. Toggle buttons
            document.getElementById('addButton').style.display = 'none';
            document.getElementById('updateButton').style.display = 'inline-block';
        }

        function updateReading() {
            const id = document.getElementById('readingIdToEdit').value;
            if (!id) {
                alert("No reading selected for update.");
                return;
            }

            const date = document.getElementById('recordDate').value;
            const time = document.getElementById('recordTime').value;
            let person = document.getElementById('personSelect').value;
            const systole = document.getElementById('systole').value;
            const diastole = document.getElementById('diastole').value;
            const glucose = document.getElementById('glucose').value;
            const weight = document.getElementById('weight').value;

            if (person === 'Custom') {
                person = document.getElementById('personCustomInput').value.trim();
            }
            if (!date || !time || !person) {
                alert("Please fill in Date, Time, and Person Name.");
                return;
            }

            const updatedReading = {
                date: date,
                time: time,
                person: person,
                systole: systole ? parseFloat(systole) : null,
                diastole: diastole ? parseFloat(diastole) : null,
                glucose: glucose ? parseFloat(glucose) : null,
                weight: weight ? parseFloat(weight) : null,
                timestamp: new Date(date + 'T' + time).getTime()
            };

            const readingRef = ref(db, 'users/' + currentUser.uid + '/healthReadings/' + id);
            update(readingRef, updatedReading)
                .then(() => {
                    // 1. Reset the form to Add mode
                    document.getElementById('readingIdToEdit').value = '';
                    document.getElementById('addButton').style.display = 'inline-block';
                    document.getElementById('updateButton').style.display = 'none';
                    
                    // 2. Clear inputs and reset person select
                    document.getElementById('systole').value = '';
                    document.getElementById('diastole').value = '';
                    document.getElementById('glucose').value = '';
                    document.getElementById('weight').value = '';
                    document.getElementById('personSelect').value = '';
                    document.getElementById('personCustomInput').value = '';
                    document.getElementById('personCustomInput').style.display = 'none';
                })
                .catch(error => {
                    alert("Failed to update reading: " + error.message);
                });
        }

        function deleteReading(id) {
            if (confirm("Are you sure you want to delete this reading?")) {
                const readingRef = ref(db, 'users/' + currentUser.uid + '/healthReadings/' + id);
                remove(readingRef)
                    .catch(error => {
                        alert("Failed to delete reading: " + error.message);
                    });
            }
        }
        
        // --- UI and Data Management ---
        function populatePersonSelect(selectPerson = null) {
            const selectEl = document.getElementById('personSelect');
            
            // Store current value to re-select after refresh
            const currentValue = selectPerson || selectEl.value;

            // Clear all options except the disabled placeholder and 'Add New'
            while (selectEl.options.length > 2) {
                selectEl.remove(1);
            }

            // Add names to the select list
            const sortedNames = Array.from(personNames).sort();
            sortedNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectEl.insertBefore(option, selectEl.options[selectEl.options.length - 1]);
            });

            // Set the selected value back
            selectEl.value = sortedNames.includes(currentValue) ? currentValue : '';
        }

        function handlePersonChange(value) {
            const customInput = document.getElementById('personCustomInput');
            if (value === 'Custom') {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
            }
        }

        function handleCustomNameBlur(value) {
            const selectEl = document.getElementById('personSelect');
            if (value.trim()) {
                // If a new name was entered, temporarily set the select value to it.
                // It will be permanently added to personNames when the reading is saved.
                selectEl.value = 'Custom'; 
                // We don't modify the options list here, only upon save.
            }
        }

        // --- Display Functions (Simplified for brevity as they are not the main issue) ---

        function loadReadings() {
            // This function is mostly handled by setupRealtimeSync, but the name is kept for structure.
        }

        function calculateAverages(readings, startDate = null) {
            const personData = {};

            readings.forEach(reading => {
                if (startDate && reading.date < startDate) return;

                const person = reading.person || 'Unknown';

                if (!personData[person]) {
                    personData[person] = {
                        count: 0,
                        systoleSum: 0,
                        diastoleSum: 0,
                        glucoseSum: 0,
                        weightSum: 0,
                        latestReading: null
                    };
                }

                const data = personData[person];

                // Check for latest reading based on date and time
                const readingDateTime = new Date(reading.date + 'T' + (reading.time || '00:00'));
                if (!data.latestReading || readingDateTime > data.latestReading.dateTime) {
                    data.latestReading = {
                        dateTime: readingDateTime,
                        ...reading
                    };
                }

                // Sum calculations for average
                let count = 0;
                if (reading.systole || reading.diastole || reading.glucose || reading.weight) {
                    // Only count if there's *any* reading data
                    data.count++;
                    count = 1; 
                }
                
                if (reading.systole !== null) data.systoleSum += reading.systole;
                if (reading.diastole !== null) data.diastoleSum += reading.diastole;
                if (reading.glucose !== null) data.glucoseSum += reading.glucose;
                if (reading.weight !== null) data.weightSum += reading.weight;
            });

            const averages = {};
            for (const person in personData) {
                const data = personData[person];
                averages[person] = {
                    count: data.count,
                    latestReading: data.latestReading,
                    avgSystole: data.systoleSum / data.count || 0,
                    avgDiastole: data.diastoleSum / data.count || 0,
                    avgGlucose: data.glucoseSum / data.count || 0,
                    avgWeight: data.weightSum / data.count || 0
                };
            }
            return averages;
        }

        function calculateAndDisplayAverages() {
            // 1. Overall Averages
            allPersonAveragesCache = calculateAverages(allReadings);
            let overallHtml = generateAveragesTableHtml(allPersonAveragesCache, 'overall');
            document.getElementById('overallAveragesContainer').innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h2>üìà Overall Averages Summary</h2>
                    <button class="table-export-btn" onclick="exportOverallAverages()">‚¨áÔ∏è Download Table (CSV)</button>
                </div>
                ${overallHtml}
            `;
            
            // 2. Today's Individual Readings
            const todayReadings = allReadings.filter(r => r.date === todayDateString);
            displayTodayIndividualReadings(todayReadings);
        }
        
        function generateAveragesTableHtml(averages, type) {
            const tableId = type === 'overall' ? 'overallAveragesTable' : 'todayAveragesTable';
            
            let tableHtml = `<table class="data-table" id="${tableId}">
                <thead>
                    <tr>
                        <th>Person</th>
                        <th>Avg. BP (Sys/Dia)</th>
                        <th>Avg. Glucose</th>
                        <th>Avg. Weight</th>
                        <th>Readings Count</th>
                    </tr>
                </thead>
                <tbody>`;

            const sortedPeople = Object.keys(averages).sort();
            
            if (sortedPeople.length === 0) {
                tableHtml += `<tr><td colspan="5" class="no-data">No data recorded yet.</td></tr>`;
            } else {
                sortedPeople.forEach(person => {
                    const avg = averages[person];
                    const bp = avg.avgSystole.toFixed(0) + ' / ' + avg.avgDiastole.toFixed(0);
                    const glucose = avg.avgGlucose.toFixed(1) + ' mg/dL';
                    const weight = avg.avgWeight.toFixed(1);
                    
                    tableHtml += `<tr>
                        <th>${person}</th>
                        <td class="avg-bp">${bp}</td>
                        <td class="avg-reading">${glucose}</td>
                        <td class="avg-reading">${weight}</td>
                        <td>${avg.count}</td>
                    </tr>`;
                });
            }

            tableHtml += `</tbody></table>`;
            return tableHtml;
        }
        
        function displayTodayIndividualReadings(todayReadings) {
            const todayContainer = document.getElementById('todayAveragesContainer');
            
            let todayHtml = `
                <h2>‚òÄÔ∏è Today's Individual Readings</h2>
                <table class="data-table" id="todayIndividualTable">
                <thead>
                    <tr>
                        <th rowspan="2">Time</th>
                        ${Array.from(personNames).sort().map(p => `<th colspan="3">${p}</th>`).join('')}
                        <th rowspan="2">Actions</th>
                    </tr>
                    <tr>
                        ${Array.from(personNames).sort().map(p => `
                            <th>BP</th>
                            <th>Glu</th>
                            <th>Wt</th>
                        `).join('')}
                    </tr>
                </thead>
                <tbody>
            `;
            
            if (todayReadings.length === 0) {
                todayHtml += `<tr><td colspan="${(Array.from(personNames).length * 3) + 2}" class="no-data">No readings recorded today.</td></tr>`;
            } else {
                // Group readings by time (for row)
                const readingsByTime = todayReadings.reduce((acc, reading) => {
                    const time = reading.time || 'Unknown';
                    if (!acc[time]) acc[time] = [];
                    acc[time].push(reading);
                    return acc;
                }, {});

                // Sort times
                const sortedTimes = Object.keys(readingsByTime).sort();

                sortedTimes.forEach(time => {
                    todayHtml += `<tr>
                        <th data-label="Time">${time}</th>`;
                    
                    const readingsAtTime = readingsByTime[time];
                    const persons = Array.from(personNames).sort();
                    
                    persons.forEach(person => {
                        const reading = readingsAtTime.find(r => r.person === person);
                        
                        if (reading) {
                            todayHtml += `
                                <td data-person="${person}" data-label="${person} BP" class="detail-reading">${reading.systole || '--'} / ${reading.diastole || '--'}</td>
                                <td data-person="${person}" data-label="${person} Glucose" class="detail-reading">${reading.glucose !== null ? reading.glucose.toFixed(1) : '--'}</td>
                                <td data-person="${person}" data-label="${person} Weight" class="detail-reading">${reading.weight !== null ? reading.weight.toFixed(1) : '--'}</td>
                            `;
                        } else {
                            todayHtml += `
                                <td data-person="${person}">--</td>
                                <td data-person="${person}">--</td>
                                <td data-person="${person}">--</td>
                            `;
                        }
                    });

                    // Action column
                    if (readingsAtTime.length > 0) {
                        const firstReading = readingsAtTime[0]; // Just take the first one to attach actions
                         todayHtml += `<td>
                            <button class="action-btn edit-btn" onclick="editReading('${firstReading.id}')">Edit</button>
                            <button class="action-btn" onclick="deleteReading('${firstReading.id}')">Delete</button>
                        </td>`;
                    } else {
                        todayHtml += `<td>--</td>`;
                    }

                    todayHtml += `</tr>`;
                });
            }
            
            todayHtml += `</tbody></table>`;
            todayContainer.innerHTML = todayHtml;
        }


        function displayDetailedHistory() {
             const detailedContainer = document.getElementById('detailedHistoryContainer');
             const daysToDisplay = 30;
             const startDate = new Date();
             startDate.setDate(startDate.getDate() - daysToDisplay + 1);
             const startDateString = startDate.toISOString().split('T')[0];
             
             // 1. Filter and group to find the LATEST reading per person per day
             const latestReadingsByDateAndPerson = {};
             allReadings.forEach(reading => {
                 if (reading.date >= startDateString) {
                     const key = `${reading.date}|${reading.person}`;
                     const readingDateTime = new Date(reading.date + 'T' + (reading.time || '00:00'));
                     
                     if (!latestReadingsByDateAndPerson[key] || readingDateTime > latestReadingsByDateAndPerson[key].dateTime) {
                         latestReadingsByDateAndPerson[key] = {
                             dateTime: readingDateTime,
                             ...reading
                         };
                     }
                 }
             });
             
             // 2. Prepare the table structure
             let tableHtml = `
                 <div style="display:flex; justify-content:space-between; align-items:center;">
                     <h2>üìÖ Detailed 30-Day Reading History (Latest Reading/Day)</h2>
                     <button class="table-export-btn" onclick="exportDetailedHistory()">‚¨áÔ∏è Download Table (CSV)</button>
                 </div>
                 <p style="text-align: center; font-style: italic; color: #555;">Showing the **latest recorded reading** for each person on a given day across the last 30 days. For a full export, please use the download button above.</p>
                 <table class="data-table" id="detailedHistoryTable">
                     <thead>
                         <tr>
                             <th rowspan="2">Date</th>
                             ${Array.from(personNames).sort().map(p => `<th colspan="4">${p}</th>`).join('')}
                         </tr>
                         <tr>
                             ${Array.from(personNames).sort().map(p => `
                                 <th>BP</th>
                                 <th>Glu</th>
                                 <th>Wt</th>
                                 <th>Time</th>
                             `).join('')}
                         </tr>
                     </thead>
                     <tbody>
             `;
             
             // 3. Generate rows (one for each day in the 30-day range)
             let rowCount = 0;
             for (let i = 0; i < daysToDisplay; i++) {
                 const currentDate = new Date(startDate);
                 currentDate.setDate(currentDate.getDate() + i);
                 const dateString = currentDate.toISOString().split('T')[0];
                 const displayDate = formatDate(dateString);

                 let rowData = '';
                 let hasDataOnDay = false;

                 Array.from(personNames).sort().forEach(person => {
                     const key = `${dateString}|${person}`;
                     const reading = latestReadingsByDateAndPerson[key];
                     
                     if (reading) {
                         hasDataOnDay = true;
                         const bp = (reading.systole || '--') + ' / ' + (reading.diastole || '--');
                         const glucose = reading.glucose !== null ? reading.glucose.toFixed(1) : '--';
                         const weight = reading.weight !== null ? reading.weight.toFixed(1) : '--';
                         
                         rowData += `
                             <td data-label="${person} BP">${bp}</td>
                             <td data-label="${person} Glucose">${glucose}</td>
                             <td data-label="${person} Weight">${weight}</td>
                             <td data-label="${person} Time">${reading.time || '--'}</td>
                         `;
                     } else {
                         rowData += `
                             <td data-label="${person} BP">--</td>
                             <td data-label="${person} Glucose">--</td>
                             <td data-label="${person} Weight">--</td>
                             <td data-label="${person} Time">--</td>
                         `;
                     }
                 });

                 // Only create a row if there was a reading for at least one person that day.
                 if (hasDataOnDay) {
                     rowCount++;
                     tableHtml += `<tr>
                         <th>${displayDate}</th>
                         ${rowData}
                     </tr>`;
                 }
             }

             if (rowCount === 0) {
                 tableHtml += `<tr><td colspan="${(Array.from(personNames).length * 4) + 1}" class="no-data">No readings in the last ${daysToDisplay} days.</td></tr>`;
             }

             tableHtml += `</tbody></table>`;
             detailedContainer.innerHTML = tableHtml;
        }

        // --- Export Functions ---
        
        // UTILITY for CSV creation
        function convertToCSV(arr) {
            if (!arr || arr.length === 0) return '';
            const header = Object.keys(arr[0]);
            const csv = [
                header.join(','),
                ...arr.map(row => header.map(fieldName => JSON.stringify(row[fieldName])).join(','))
            ].join('\n');
            return csv;
        }
        
        // UTILITY for downloading the CSV string
        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
        
        function exportFullHistory() {
            // Map the full history to a flat object array for CSV export
            const exportData = allReadings.map(r => ({
                Date: r.date,
                Time: r.time,
                Person: r.person,
                Systolic: r.systole,
                Diastolic: r.diastole,
                Glucose: r.glucose,
                Weight: r.weight,
                Reading_ID: r.id
            }));
            
            const csv = convertToCSV(exportData);
            downloadCSV(csv, 'health_tracker_full_history.csv');
        }

        function exportOverallAverages() {
            const exportData = Object.keys(allPersonAveragesCache).map(person => {
                const avg = allPersonAveragesCache[person];
                return {
                    Person: person,
                    Avg_Systolic: avg.avgSystole.toFixed(0),
                    Avg_Diastolic: avg.avgDiastole.toFixed(0),
                    Avg_BP: `${avg.avgSystole.toFixed(0)} / ${avg.avgDiastole.toFixed(0)}`,
                    Avg_Glucose: avg.avgGlucose.toFixed(1),
                    Avg_Weight: avg.avgWeight.toFixed(1),
                    Readings_Count: avg.count
                };
            });
            
            const csv = convertToCSV(exportData);
            downloadCSV(csv, 'health_tracker_overall_averages.csv');
        }

        function exportDetailedHistory() {
            // A more complex export based on the table structure (latest per day/person)
            const daysToDisplay = 30;
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - daysToDisplay + 1);
            const startDateString = startDate.toISOString().split('T')[0];
            const latestReadingsByDateAndPerson = {};
            
            allReadings.forEach(reading => {
                 if (reading.date >= startDateString) {
                     const key = `${reading.date}|${reading.person}`;
                     const readingDateTime = new Date(reading.date + 'T' + (reading.time || '00:00'));
                     
                     if (!latestReadingsByDateAndPerson[key] || readingDateTime > latestReadingsByDateAndPerson[key].dateTime) {
                         latestReadingsByDateAndPerson[key] = {
                             dateTime: readingDateTime,
                             ...reading
                         };
                     }
                 }
             });

            const exportArr = [];
            const sortedPeople = Array.from(personNames).sort();
            
            for (let i = 0; i < daysToDisplay; i++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(currentDate.getDate() + i);
                const dateString = currentDate.toISOString().split('T')[0];

                let row = { 'Date': dateString };
                let hasData = false;

                sortedPeople.forEach(person => {
                    const reading = latestReadingsByDateAndPerson[`${dateString}|${person}`];
                    if (reading) {
                        hasData = true;
                        row[`${person}_BP`] = (reading.systole || '') + '/' + (reading.diastole || '');
                        row[`${person}_Glucose`] = reading.glucose || '';
                        row[`${person}_Weight`] = reading.weight || '';
                        row[`${person}_Time`] = reading.time || '';
                    } else {
                        row[`${person}_BP`] = '';
                        row[`${person}_Glucose`] = '';
                        row[`${person}_Weight`] = '';
                        row[`${person}_Time`] = '';
                    }
                });
                
                if (hasData) {
                    exportArr.push(row);
                }
            }

            if (exportArr.length > 0) {
                const csv = convertToCSV(exportArr);
                downloadCSV(csv, 'health_tracker_30day_detailed_history.csv');
            } else {
                 alert("No data available in the last 30 days to export.");
            }
        }

    </script>

</body>
</html>
